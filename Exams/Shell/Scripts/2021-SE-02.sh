#Един от често използваните DNS сървъри е BIND9, при който описанието на DNS зоните обикновенно стои в текстови файлове, наричани зонални файлове. За улеснение, в рамките на задачата,
#ще ползваме опростено описание на зоналните файлове.
#Под whitespace разбираме произволна комбинация от табове и интервали.
#Под FQDN разбираме низ, който има допустими символи малки латински букви, цифри и точка; не
#може да започва с точка, не може да има две или повече съседни точки, задължително завършва
#с точка.
#Зоналните файлове съдържат ресурсни записи, по един на ред. Общият вид на даден ресурсен запис
#e <ключ> <TTL> <клас> <тип> <RDATA>, разделени с whitespace, например:
#astero.openfmi.net. 3600 IN A 185.117.82.99
#Където:
#• ключ (astero.openfmi.net.) – FQDN
#• TTL (3600) – цифри; полето може да липсва
#• клас (IN) - главни латински букви; класът винаги е IN
#• тип (A) - главни латински букви; някое от SOA, NS, A, AAAA
#• RDATA (185.117.82.99) - данни на записа; различни за различните типове ресурсни записи;
#всичко след типа до края на реда.
#Знакът точка-и-запетая ; е знак за коментар, и всичко след него до края на реда се игнорира.
#Във всеки зонален файл трябва да има точно един SOA запис, и той трябва да е първият запис във
#файла. Пример за едноредов SOA запис:
#openfmi.net. 3600 IN SOA nimbus.fccf.net. root.fccf.net. 2021041901 86400 7200 3024000 3600
#RDATA-та на SOA запис се състои от два FQDN-а и пет числа, разделени с whitespace.
#Въпреки, че горното е валиден SOA запис, за прегледност в зоналните файлове често се ползва
#следният синтаксис (многоредов SOA запис, еквивалентен на горния):
#openfmi.net. 3600 IN SOA nimbus.fccf.net. root.fccf.net. (
#2021041901 ; serial
#86400 ; refresh
#7200 ; retry
#3024000 ; expire
#3600 ; negative TTL
#)
#т.е., поредицата от числа се разбива на няколко реда, оградени в обикновенни скоби, и за всяко
#число се слага коментар какво означава.
#Първото от тези числа (serial) представлява серийният номер на зоната, който трябва да се увеличава всеки път, когато нещо в зоналният файл се промени. Изключително важно е това число само
#да нараства, и никога да не намалява.
#Един от често използваните формати за сериен номер, който показва кога е настъпила последната
#промяна в зоналния файл представлява число във вида YYYYMMDDTT, т.е., четири цифри за
#година, две цифри за месец, две цифри за дата и още две цифри за поредна промяна в рамките на
#описания ден. За последните две цифри (ТТ) има ограничение да са от 00 до 99 (естествено, така
#не може да има повече от 100 промени в рамките на един ден).
#За удобство приемаме, че конкретен сериен номер (точната поредица цифри) се среща само на едно
#място в зоналния файл.
#Напишете шел скрипт, който по подадени имена на зонални файлове променя серийният номер в
#SOA записа на всеки файл по следният алгоритъм:
#18
#• ако датата в серийният номер е по-стара от днешната, новият сериен номер трябва да е от
#вида днешнадата00
#• ако датата в серийният номер е равна на днешната, серийният номер трябва да се увеличи с
#единица
#Важат следните условия:
#• скриптът трябва да може да обработва и едноредови, и многоредови SOA записи
#• за всеки зонален файл, който не е успял да обработи, скриптът трябва да вади съобщение за
#грешка, което включва и името на зоналния файл. Съобщенията трябва да са лесно обработваеми с познатите инструменти за обработка на текст.

#!/bin/bash

if [[ $# -lt 1 ]]; then
    echo "Usage: $0 <zone_file1> [zone_file2 ...]"
    exit 1
fi

TODAY=$(date +%Y%m%d)

for ZONE in "$@"; do
    if [[ ! -f "$ZONE" ]]; then
        echo "Error: $ZONE not found"
        continue
    fi

    SOA_LINE=$(grep -m1 "SOA" "$ZONE")
    if [[ -z "$SOA_LINE" ]]; then
        echo "Error: SOA record not found in $ZONE"
        continue
    fi

    SER_NUM=$(grep -v '^;' "$ZONE" | tr -d '()' | tr -s ' ' | grep SOA -A5 | tr -s ' ' | awk '{for(i=1;i<=NF;i++){if($i ~ /^[0-9]{10}$/){print $i; exit}}}')

    if [[ -z "$SER_NUM" ]]; then
        echo "Error: serial not found in $ZONE"
        continue
    fi

    # Вземаме дата (първите 8 цифри) и суфикс (последните 2 цифри)
    SER_DATE=${SER_NUM:0:8}
    SER_SUFFIX=${SER_NUM:8:2}

    if [[ "$SER_DATE" -lt "$TODAY" ]]; then
        NEW_SER="${TODAY}00"
    else
        TT=$(printf "%02d" $((10#$SER_SUFFIX + 1)))
        if [[ "$TT" -gt 99 ]]; then
            TT="99"
        fi
        NEW_SER="${TODAY}${TT}"
    fi

    sed -i "s/$SER_NUM/$NEW_SER/" "$ZONE"

    echo "Updated $ZONE: $SER_NUM -> $NEW_SER"

done
