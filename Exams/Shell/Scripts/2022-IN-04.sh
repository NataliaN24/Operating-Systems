Вашите колеги от съседната лаборатория работят със специализирана система Fuga, която се базира
на два текстови файла – за автентификация (foo.pwd) и основен конфигурационен файл (foo.conf).
Двата файла би трябвало да се съхраняват в главната директория на системата, която ще наричаме
fuga.
На всеки ред във първия файл има потребителско име (малки латински букви) и паролата за този
потребител, разделени с двоеточие, като паролата не е в чист вид, а е хеширана.
Форматът на конфигурационния файл е недефиниран. Тъй като конфигурационният файл е твърде
голям за удобна работа, вашите колеги са решили да го разделят на части в отделни малки конфигурационни файлове, които държат в директория fuga/cfg и нейните под-директории. Всеки такъв файл
има име във формат bar.cfg, където bar е име на потребител на системата. Колегите ви са написали
скрипт (fuga/validate.sh), който приема един задължителен позиционен аргумент – име на конфигурационен файл. Скриптът проверява указания конфигурационен файл за валиден синтаксис и
може да приключи с някой от следните exit code-ове:
• 0 – файлът е валиден;
• 1 – файлът не е валиден;
• 2 – настъпила е грешка при изпълнение на скрипта.
Ако файлът не е валиден, скриптът извежда на stdout редовете, на които има грешка, предхождани от
Line x: където 𝑥 е номера на реда. В останалите случаи скриптът няма изход.
Разполагате с команда pwgen, която генерира и извежда на stdout случайни пароли (букви и цифри),
и знаете, че поддържа следните два аргумента: pwgen [password_length] [number_of_passwords]
Също така разполагате с командата mkpasswd, която по подаден аргумент – парола в чист вид извежда
нейният хеш на stdout.
Помогнете на колегите си, като напишете шел скрипт, който приема параметър – име на директория
fuga. Скриптът трябва да:
• извежда на stderr грешните редове от малките конфигурационни файлове, във формата извеждан от валидиращия скрипт, като всеки ред трябва да започва с името на конфигурационния
файл и знак двоеточие ’:’;
• (ре-)генерира foo.conf като конкатенация на валидните малки конфигурационни файлове;
• провери за всеки валиден малък конфигурационен файл дали потребителят съществува в автентификационния файл и ако не – да го добави по подходящия начин, като изведе на stdout
потребителското име и паролата в чист вид, разделени с двоеточие.

#!/bin/bash

if [ -z "$1" ]; then
    echo "Usage: $0 fuga_dir" >&2
    exit 1
fi

FUGA_DIR="$1"
CFG_DIR="$FUGA_DIR/cfg"
PWD_FILE="$FUGA_DIR/foo.pwd"
OUT_CONF="$FUGA_DIR/foo.conf"

> "$OUT_CONF"

find "$CFG_DIR" -type f -name "*.cfg" | while read -r cfgfile; do

    "$FUGA_DIR/validate.sh" "$cfgfile"
    EXIT_CODE=$?
    if [ $EXIT_CODE -eq 0 ]; then
      
        cat "$cfgfile" >> "$OUT_CONF"
     
        USERNAME=$(basename "$cfgfile" .cfg)
       
        if ! grep -q "^$USERNAME:" "$PWD_FILE"; then
          
            PASSWORD=$(pwgen 16 1)
            HASH=$(mkpasswd "$PASSWORD")
      
            echo "$USERNAME:$HASH" >> "$PWD_FILE"
            
            echo "$USERNAME:$PASSWORD"
        fi
    elif [ $EXIT_CODE -eq 1 ]; then
   
        "$FUGA_DIR/validate.sh" "$cfgfile" | sed "s|^|$cfgfile:|"
    else

        echo "Error processing $cfgfile" >&2
    fi
done

