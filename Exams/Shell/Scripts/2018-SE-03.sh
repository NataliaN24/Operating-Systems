#Напишете скрипт, който приема два позиционни аргумента – имена на текстови
#файлове в CSV формат:
#8,foo,bar,baz
#2,quz,,foo
#12,1,3,foo
#3,foo,,
#5,,bar,
#7,,,
#4,foo,bar,baz
#10
#Валидни са следните условия:
#• CSV файловете представляват таблица, като всеки ред на таблицата е записан на отделен ред;
#• на даден ред всяко поле (колона) е разделено от останалите със запетая;
#• броят на полетата на всеки ред е константа;
#• в полетата не може да присъства запетая, т.е., запетаята винаги е разделител между полета;
#• ако във файла присъстват интервали, то това са данни от дадено поле;
#• първото поле на всеки ред е число, което представлява идентификатор на реда (ID).
#Примерно извикване: ./foo.sh a.csv b.csv
#Скриптът трябва да чете a.csv и на негова база да създава b.csv по следния начин:
#• някои редове във файла се различават само по колоната ID, и за тях казваме, че формират
#множество Ai
#• за всяко такова множество Ai да се оставя само един ред - този, с най-малка стойност на ID-то;
#• редовете, които не са членове в някое множество Ai се записват в изходния файл без промяна.

#!/bin/bash

if [ $# -ne 2 ]; then
    echo "Usage: $0 input.csv output.csv"
    exit 1
fi

INPUT="$1"
OUTPUT="$2"

if [ ! -f "$INPUT" ]; then
    echo "Error: input file does not exist."
    exit 1
fi

awk -F',' '
{
    id = $1
    # key = всичко след първата колона
    key = substr($0, index($0, ",") + 1)

    if (key == "") {
        # ред с едно поле (само ID)
        key = "__EMPTY__"
    }

    # ако още нямаме ред за този key или текущият ID е по-малък → запомни
    if (!(key in best) || id < best_id[key]) {
        best[key] = $0
        best_id[key] = id
    }
}
END {
    for (k in best) {
        print best[k]
    }
}
' "$INPUT" > "$OUTPUT"
